"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SQLiteDatabase = void 0;
const sqlite3_1 = __importDefault(require("sqlite3"));
sqlite3_1.default.verbose();
const splitterChar = `\\/?!*^$£µ&@|øÎ▒ÿ`;
class SQLiteDatabase {
    constructor(path) {
        this.path = path;
        this.db = new sqlite3_1.default.Database(path, (err) => {
            if (err)
                throw new Error('Failed to create a new SQLite database.\n' + err);
        });
    }
    ;
    create(...tables) {
        const codes = [];
        for (const table of tables) {
            const keys = [...Object.keys(table.keys)];
            if (keys.includes('name'))
                throw new Error('The name \'name\' is prohibited.');
            const arr = [];
            let primaryKeysCount = 0;
            for (const key of keys) {
                arr.push(`${key} ${(table.keys[key][0] !== 'INTEGER' && table.keys[key][1]?.autoincrement) ? 'INTEGER' : table.keys[key][0]} ${table.keys[key][1]?.primary && primaryKeysCount < 1 ? 'PRIMARY KEY' : ''} ${table.keys[key][1]?.autoincrement && table.keys[key][0] === 'INTEGER' ? 'AUTOINCREMENT' : ''}`);
                if (table.keys[key][1]?.primary)
                    primaryKeysCount++;
            }
            ;
            if (primaryKeysCount <= 0)
                throw new Error('Required at least one primary column.');
            if (primaryKeysCount > 1)
                throw new Error('More than one primary key provided.');
            const code = `CREATE TABLE ${table.overwrite ? 'IF NOT EXISTS' : ''} ${table.name}(${arr.join(', ')})`
                .replace(/BOOLEAN|ARRAY/g, 'TEXT');
            codes.push(code);
        }
        ;
        return new Promise((res, rej) => {
            for (const code of codes) {
                this.db.run(code, (err) => {
                    if (err)
                        return rej(err);
                    res(this);
                });
            }
            ;
        });
    }
    ;
    drop(...names) {
        const codes = [];
        for (const name of names) {
            const code = `DROP TABLE ${name}`;
            codes.push(code);
        }
        ;
        return new Promise((res, rej) => {
            for (const code of codes) {
                this.db.run(code, (err) => {
                    if (err)
                        return rej(err);
                    res(this);
                });
            }
            ;
        });
    }
    ;
    ensure(name, where) {
        const code = `SELECT name FROM sqlite_master WHERE type='table' AND name=?`;
        return new Promise((res, rej) => {
            this.db.get(code, [name], async (err, row) => {
                if (err)
                    return rej(err);
                if (where) {
                    const selected = await this.select(name, where);
                    if (selected.length > 0)
                        res(true);
                    else
                        res(false);
                }
                else {
                    if (row)
                        res(true);
                    else
                        res(false);
                }
                ;
            });
        });
    }
    ;
    insert(name, data) {
        const keys = [...Object.keys(data)];
        const values = [...Object.values(data)];
        const newValues = [];
        for (const value of values) {
            if (typeof value === 'string' && (value === 'boolean-true' || value === 'boolean-false'))
                throw new Error('The method is not allowed.');
            if (typeof value === 'boolean') {
                newValues.push(`${value ? 'boolean-true' : 'boolean-false'}`);
            }
            else if (Array.isArray(value)) {
                newValues.push(`${value.length <= 0 ? `${splitterChar}` : (value.length === 1 ? `${value}${splitterChar}` : value.join(splitterChar))}`);
            }
            else
                newValues.push(value);
        }
        ;
        const code = `INSERT INTO ${name} (${keys.join(', ')}) VALUES (${keys.map(() => '?').join(',')})`;
        return new Promise((res, rej) => {
            this.db.run(code, newValues, (err) => {
                if (err)
                    return rej(err);
                res(this);
            });
        });
    }
    ;
    delete(name, where) {
        const arr = [];
        if (where) {
            const keys = [...Object.keys(where)];
            for (const key of keys) {
                if (key === 'name')
                    continue;
                arr.push(`${key}=${typeof where[key] === 'string' ? `'${where[key]}'` : where[key]}`);
            }
            ;
        }
        ;
        const code = `DELETE FROM ${name} WHERE ${arr.join(' AND ')}`;
        return new Promise((res, rej) => {
            this.db.run(code, (err) => {
                if (err)
                    return rej(err);
                res(this);
            });
        });
    }
    ;
    select(name, where) {
        const arr = [];
        if (where) {
            const keys = [...Object.keys(where)];
            for (const key of keys) {
                if (key === 'name')
                    continue;
                arr.push(`${key}=${typeof where[key] === 'string' ? `'${where[key]}'` : where[key]}`);
            }
            ;
        }
        ;
        const code = `SELECT * FROM ${name} ${arr.length > 0 ? `WHERE ${arr.join(' AND ')}` : ''}`;
        return new Promise((res, rej) => {
            this.db.all(code, [], (err, rows) => {
                if (err)
                    return rej(err);
                const newRows = [];
                for (const row of rows) {
                    const stringified = JSON.stringify(row)
                        .replace(/"boolean-true"/g, 'true')
                        .replace(/"boolean-false"/g, 'false');
                    const parsed = JSON.parse(stringified);
                    const keys = [...Object.keys(parsed)];
                    let obj = parsed;
                    for (const key of keys) {
                        if (typeof obj[key] !== 'string')
                            continue;
                        if (obj[key].includes(splitterChar)) {
                            let split = obj[key].split(splitterChar);
                            if (split[split.length - 1].length <= 0)
                                split.pop();
                            obj[key] = split;
                        }
                        ;
                    }
                    ;
                    newRows.push(parsed);
                }
                ;
                res(newRows);
            });
        });
    }
    ;
    selectFirst(name, where) {
        return new Promise((res, rej) => {
            this.select(name, where)
                .then((arr) => {
                arr.length <= 0 ? res(null) : res(arr[0]);
            })
                .catch(rej);
        });
    }
    ;
    close() {
        return new Promise((res, rej) => {
            this.db.close((err) => {
                if (err)
                    return rej(err);
                res(this);
            });
        });
    }
    ;
}
exports.SQLiteDatabase = SQLiteDatabase;
;
//# sourceMappingURL=SQLiteDatabase.js.map