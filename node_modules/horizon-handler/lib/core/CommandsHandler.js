"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsHandler = void 0;
const discord_js_1 = require("discord.js");
const CommandBuilder_1 = require("./CommandBuilder");
const utils_1 = require("./utils");
const events_1 = require("events");
class CommandsHandler extends events_1.EventEmitter {
    /**
     * Creates a new handler for Discord API interaction application commands.
     * @param {string} path The directory path.
     * @param {boolean | undefined} includesDir Whenever the directory has sub-dirs or not.
     * @typeParam {Client} C The Discord bot Client.
     * @typeParam {{}} O Custom options.
     * @typeParam {any[]} A Custom run arguments.
     */
    constructor(path, includesDir) {
        super({ captureRejections: false });
        this.collection = new discord_js_1.Collection();
        this.includesDir = false;
        /**
         * Creates a new command.
         *
         * **Warning**: Make sure that you have exported it as `default`.
         *
         * ```ts
         * // TypeScript
         * export default new [handler].command(...);
         *
         * // JavaScript (CommonJS)
         * module.exports = new [handler].command(...);
         * ```
         */
        this.command = class extends CommandBuilder_1.CommandBuilder {
            constructor(data) {
                super(data);
            }
            ;
        };
        if (!path)
            throw new utils_1.HorizonError('MissingRequiredParameter', '\'path\' is required for the constructor.');
        if (includesDir && typeof includesDir !== 'boolean')
            throw new utils_1.HorizonError('InvalidParameterType', '\'includesDir\' is not type of boolean.');
        this.path = path;
        this.includesDir = includesDir;
    }
    ;
    /**
     * Deploy application commands to Discord API using `REST` client.
     * @param {Client<true>} client The Discord bot client, must be ready.
     * @param {{ REST?: RESTOptions, guildId?: string }} options
     * @returns
     */
    deploy(client, options) {
        if (!client)
            throw new utils_1.HorizonError('MissingRequiredParameter', '\'client\' is required for the method.');
        if (!client.isReady())
            throw new utils_1.HorizonError('DiscordClientError', 'The client is not ready yet.');
        return new Promise(async (resolved, rejected) => {
            try {
                const rest = new discord_js_1.REST(options?.REST).setToken(client.token);
                this.emit('deployStart');
                if (options?.guildId && client.guilds.cache.get(options.guildId)) {
                    await rest.put(discord_js_1.Routes.applicationGuildCommands(client.user.id, options.guildId), {
                        body: [...this.collection.values()].map((command) => command.structure)
                    });
                    this.emit('deployFinish');
                }
                else {
                    await rest.put(discord_js_1.Routes.applicationCommands(client.user.id), {
                        body: [...this.collection.values()].map((command) => command.structure)
                    });
                    this.emit('deployFinish');
                }
                ;
                resolved(rest);
            }
            catch (e) {
                this.emit('deployError', e);
                rejected(e);
            }
            ;
        });
    }
    ;
    /**
     * Loads all commands from the provided path.
     */
    load() {
        return new Promise(async (resolved, rejected) => {
            try {
                const data = await (0, utils_1.importFromDir)(this.path, {
                    includesDir: this.includesDir
                });
                for (const command of data) {
                    if (!command.structure || !command.run || !command.type || command.disabled) {
                        this.emit('fileSkip', command.structure);
                        continue;
                    }
                    ;
                    this.collection.set(command.structure.name, command);
                    this.emit('fileLoad', command.structure);
                }
                ;
                resolved(data);
            }
            catch (e) {
                rejected(e);
            }
            ;
        });
    }
    ;
    /**
     * Reloads all commands from the provided path.
     */
    reload() {
        return new Promise(async (resolved, rejected) => {
            try {
                this.collection.clear();
                const output = await this.load();
                resolved(output);
            }
            catch (e) {
                rejected(e);
            }
            ;
        });
    }
    ;
    addCommands(...commands) {
        for (const command of commands) {
            if (!command || !command.structure || !command.run || !command.type)
                continue;
            this.collection.set(command.structure.name, command);
        }
        ;
        return this;
    }
    ;
    setCommands(...commands) {
        this.collection.clear();
        for (const command of commands) {
            if (!command || !command.structure || !command.run || !command.type)
                continue;
            this.collection.set(command.structure.name, command);
        }
        ;
        return this;
    }
    ;
}
exports.CommandsHandler = CommandsHandler;
;
//# sourceMappingURL=CommandsHandler.js.map